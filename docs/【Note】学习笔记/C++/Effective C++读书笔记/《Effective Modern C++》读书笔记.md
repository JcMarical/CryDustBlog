# 1.理解模板类型推导：
```c++
template<typename T> 
void f(ParamType param); 
f(expr); //从expr中推导T和ParamType
```
- ParamType是指针或引用，但不是通用引用：T&或`*`或 const T&
	- expr为引用，推导忽略引用部分
	- expr的类型于ParamType进行模式匹配来决定T类型(主要是const部分)
- ParamType为通用引用：T&&
	- 传入左值，推导为左值引用。（和T&一样）
	- 传入右值，推导为右值引用。
- ParamType既非指针也非引用（值传递）
	- 类型消除：消除**引用**部分、**const**部分、**volatile**部分
- 数组实参：数组应尽量使用引用传参。
	- 指针赋值：退化
	- 模板T传数组：视作指针声明，退化成指针
	- 模板T&传数组：视作引用，推导成真正的数组
- 函数实参退化成函数指针：T退化成void`(*) `指针，T&推导成`void（&）指针
# 2，理解auto类型推导
依赖于模板推导，基本一样
特殊点：
- `{}`:会被auto推导成initialize_list的类型，而T模板推导会报错
- C++14允许出现在函数返回值和lambda参数

# 3. 理解decltype

## 4. 查看类型推导结果

---
## 5. 优先考虑auto
- 变量必须初始化
- 重构方便
- 存在一些陷阱（未推导出理想的值）

## 6. auto推导若非己愿，显示类型初始化惯用法
- **代理类**可能会使auto推导出“错误类型”
- 显式类型初始器惯用法强制auto推导出想要的结果

