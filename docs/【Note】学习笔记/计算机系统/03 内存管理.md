# 03 内存管理

![](https://i-blog.csdnimg.cn/blog_migrate/7683669ed7196d7d6f4ab9817f255c03.jpeg)

# 一 虚拟内存
进程持有的虚拟地址会通过 CPU 芯片中的**内存管理单元（MMU）** 的映射关系，来转换变成物理地址。

![[Pasted image 20250720021047.png]]


## 1.1 内存分段
- **四个段**：**代码分段、数据分段、栈段、堆段**
- 分段机制下的虚拟地址由两部分组成，**段选择因子**（**段号**）和**段内偏移量**
- **段表**：段的**基地址**、**界限**、特权等级
问题：
- 内存碎片（外部内存碎片）
- 内存交换效率低

## 1.2 内存分段
- Linux:4KB
- 页表：存储在内存里的，CPU的**内存管理单元MMU** 负责将虚拟内存地址转换成物理地址
- **缺页异常**：
- 内存碎片：无外部，有内部内存碎片
- 页面置换：最近未被使用LRU，一次一个或几个页，**内存交换的效率就相对比较高。**
- 分段机制下的虚拟地址由两部分：**页号+页内偏移量**
- **页表**:页表由**虚拟页号对应物理页号**,含物理页每页所在**物理内存的基地址**，
- 简单分页的问题：32位--每个进程都有一个4MB内存存页表，那100个进程就是巨大的开销
- **多级页表**： 100 多万个「页表项」的单级页表再分页
	- 二级页表虚拟地址由：一级页表+二级页表+页内偏移组成
	- **为什么不会更大**？程序一般不会使用大量空间，需要时才会创建对应的二级页表。
	- 64位已经发展到4级目录了
- TLB快表(页表缓存)：程序是有局部性，把最常访问的几个页表项存储到访问速度更快的硬件（CPU）。
	- 是一种Cache，装在CPU里，和MMU交互
	- 命中率很高，CPU在寻址时，会先查TLB

## 1.3 段页式内存管理
- 地址结构：**段号、段内页号和页内位移**
- 内存：每一个程序一张段表，每个段又建立一张页表

## 1.4 Linux内存布局
- 早期IntelCPU：（段+偏移）逻辑地址-段式内存管理->线性（虚拟）地址-页式内存管理->物理地址
- **Linux 系统中的每个段都是从 0 地址开始的整个 4GB 虚拟空间**，**屏蔽了处理器中的逻辑地址概念**
- **Linux分内核空间和用户空间**：
	-  进程在用户态时，只能访问用户空间内存；进入内核态后，才可以访问内核空间的内存；
	- 内核地址：每个进程都各自有独立的虚拟内存。但是**每个虚拟内存中的内核地址，关联的都是相同的物理内存**。切换到内核态后，就可以很方便地访问内核空间内存
	- 用户空间内存：从下到上
		- 保留区：非合法地址，比如无效指针的NULL指向这块
		- 代码段：二进制可执行代码+常量
		- 数据段：已初始化的静态变量+全局变量
		- BSS段：未初始化的~
		- 堆段：动态分配的内存，动态分配
		- 文件映射段：**动态库**，**共享内存**，动态分配
		- 栈段