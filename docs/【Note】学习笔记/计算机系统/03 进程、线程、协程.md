- PCB结构：按加载顺序
	- **资源分配清单**
		- 文件描述符
		- 文件系统
		- 信号
		- 信号处理函数
		-  mm_struct：虚拟内存空间分配
		- 命名空间
		- IO信息等

		- 分配pid等
	- **进程当前状态和优先级**
	- **CPU相关信息**
	- **进程描述信息**
		- 进程标识符pid
		- 用户标识符
- 进程状态与执行：链表管理组织PCB，上下文切换，保存进程信息到硬盘进入阻塞队列。
- 链表：就绪队列和阻塞队列。
- CPU上下文切换
	- 进程：**进程的上下文切换不仅包含了虚拟内存、栈、全局变量等用户空间的资源，还包括了内核堆栈、寄存器等内核空间的资源。**
	- 线程：
		- 不是一个进程：当两个线程不是属于同一个进程，则切换的过程就：跟进程上下文切换一样；
		- 当两个线程是属于同一个进程，因为虚拟内存是共享的，所以在切换时，虚拟内存这些资源就保持不动，只需要切换线程的**私有数据（栈）、寄存器**等不共享的数据；
- 进程通信：
	- 管道:匿名（仅fd）和命名
		- 内核建立缓存，命名会开辟一个设备文件
		- 效率低，单向流式传输
	- 消息队列：内核的消息**链表**
		- 不及时，大小限制
		- 消息拷贝开销
	- 共享内存：
		- 最快
		- 需要做临界资源的控制
	- 信号+信号处理函数
	- Socket
## 锁的机制

## 死锁
四大条件
- （多线程）互斥（一个资源）
- 持有（资源）并等待（其他线程释放）
- 不可剥夺（已有线程的资源）
- （线程间）环路等待

尽量避免：
- 资源有序分配
- 银行家算法


## 死锁预防（破坏必要条件）​

### ⚙️ ​**​一、死锁预防（破坏必要条件）​**​

通过设计破坏死锁的至少一个必要条件：

 1.​**​破坏占有且等待​**​
 - ​**​一次性申请所有资源​**​：线程启动前必须申请全部所需资源，否则不执行（如C++的`std::lock`同时获取多个锁）
-  ​**​超时机制​**​：尝试获取锁时设置超时（如Java的`tryLock(timeout)`），超时后释放已有锁并重试
2. ​**​破坏不可抢占​**​
- 允许系统强制回收资源（如数据库事务回滚），但需处理数据一致性
3.  ​**​破坏循环等待​**​
- ​**​固定资源顺序​**​：所有线程按全局编号顺序申请资源（如先锁A再锁B）
- ​**​层级锁​**​：资源分层管理，线程按层级加锁
2. 破坏互斥条件（如将某些资源改为共享访问）。'


## 二.死锁避免
- **银行家算法**
- **资源有序分配法​**；结合编号机制，确保资源请求路径无环

###  三. 检测方法
**资源分配图**：检测图中是否存在环路
**等待图分析​**​：构建进程等待链，发现环路即死锁


### 四. 鸵鸟策略
​**​不处理死锁​**​，依赖用户干预或重启系统

# 五.无锁结构
- 原子变量
- 