# 存储器
- 寄存器
- CPUCache--L1、L2、L3
- 内存
- SSD/HDD硬盘

# 关系
速度：L1比内存快100倍，内存比硬盘块10~1000倍

# 寄存器
数量：几十到几百
特点：最快、最贵




# CPU Cache--SRAM
## 1. 层次结构
- L1
	- 单核心对应一个**指令缓存+数据缓存**
	- 大小：32KB~128KB，大部分是64KB
	- 时间：2~4个时钟周期
- L2：
	- 和其对应的L1都**在同一个核心**中
	- 几百KB到几MB
- L3：
	- 多核心公用
	- 连接内存
	- 几MB到几十MB
## 2.Cache Line(Cache机制)


### **内存的访问方式**
- **组标记**：区分对应的内存块，若不匹配则重新读取
- **索引**：访问到具体的内存位置
- **偏移量**：访问到内存块的偏移
其他
- - 有效位：判断是否有效，用来重新从内存读入（volatile作用）
### 映射方式
一般采取：**组间直接映射+组内全相联映射**

**直接映射：**
内存块大小：基本上都是**64字节**
缓存块位置：内存块地址**取模运算**
- 这意味着一个**cacheline对应多个内存块**，用组标记来判断

**组内全相联映射：**
- 多个cacheline分为一组（一般是4路）

其他数据：
- 组标记：区分对应的内存块



## 3.CPU优化--缓存命中率
**1. 数据缓存优化**：
- 遍历数组
**2.指令缓存优化**：
- **CPU分支预测**：提前缓存if或else中的指令
- 例子：先排序后遍历 快于 先遍历后排序

**3.多核 CPU--缓冲命中率提升**
- 问题：L1、L2核心独有，线程切换核心导致缓存更改
- 解决：绑定线程到核心


## 4.缓存一致性与MESI
缓存写入内存：
- **写直达**：性能影响大
	- 缓存数据存在，同时写到缓存和内存
	- 缓存数据不存在，直接写到内存
- **写回**：性能提高，更复杂
	- 先写到缓存中，**被替换时**再写到内存
	- **脏标记机制**：下次写入\读取时发现脏标记，写入内存
	- 本身不负责写入内存，只实现修改脏标记

缓存一致性问题（多核心）：
- 原因：A核心和B核心同一数据可能**因为写回机制**缓存不一致，可能导致缓存读取出错。
- 缓存数据同步：
	- **写传播**：某个核心Cache更新时，必须传播到其他核心
	- **事务的串行化**：保证所有核心对数据的**操作顺序一致**，
- MESI协议：实现缓存一致
	- 四种状态：已修改（脏标记），独占（单核，自由写入）、共享（广播）、已失效（不可读取）
	- 共享独占的判断：读取一个数据时，发送消息给其他核心，多核心则变为**共享**，没有就**独占**
	- **共享更新数据（一致性实现）**：广播，其他核心变为**无效**状态，自己标记为**已修改**

## 5.性能杀手--多线程的伪共享
原因：明明是不同的数据，却在多线程多核心的同一Chcheline，MESI中是**伪【共享】** 的状态
独占肯定比共享性能更优

解决办法：
- aliganas(64)强制内存对齐
- char填充对齐
- 还有一些宏用来分离到不同cacheline

## 6.常见游戏优化：
- ECS
- 对象池
- 资源聚类与预加载
- 减少伪共享

# 内存--DRAM
访问速度：约200~300个时钟周期，即CPU的200~300倍时间，较慢
