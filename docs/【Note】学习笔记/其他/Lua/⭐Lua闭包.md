# Upvalue
upvalue 是闭包（closure）概念的一个重要组成部分。一个 upvalue 指的是一个函数内部所引用的外部局部变量。这些变量不是函数的参数，也不是函数内部定义的局部变量，而是定义在函数外部的局部变量。

当一个 Lua 函数引用了它外部作用域中的局部变量时，这个局部变量就成了一个 upvalue。这样，即使外部函数的执行已经结束，引用了这个局部变量的内部函数仍然可以访问和修改这个变量的值。

>注意区分C++和lua。c++是拷贝，而lua是**引用**

## 共享
由于lua的**引用**机制：
	如果两个或多个闭包引用了同一个外部局部变量，它们实际上是共享同一个 upvalue。这意味着当其中一个闭包修改了这个变量时，其他闭包看到的该变量的值也会改变。

## 关闭和开启
当一个闭包被创建时，Lua 会“开启”（open）这些 upvalue，确保这些变量可以被闭包访问。当没有任何闭包引用这些 upvalue 时，Lua 会“关闭”（close）它们，这意味着相关的资源可以被回收。

## 存储细节
在lua中，会生成一个全局栈，所有的upvalue都会指向该栈中的值，若对应的参数离开的作用域，栈中的值也会被释放，upvalue的指针会指向自己，等待被gc

闭包运行时，会通过创建指向upvalue的指针，并循环upvalue linked list，找到所需要的外部变量进行运行



# 闭包
闭包=函数+引⽤环境
所谓闭包，简单地理解，**它其实是一个函数，不过它访问了另外一个函数词法作用域中的变量。**



## lua所有函数都是闭包
如果按照闭包的定义来看，Lua 的所有函数实际上都是闭包，即使你没有嵌套。这是因为 Lua 编译器会把 Lua 脚本外面，再包装一层主函数。比如下面这几行简单的代码段：
```lua
local foo, bar
local function fn()
  foo = 1
  bar = 2
end
```

在编译后，就会变为下面的样子：
```lua
function main(...)
  local foo, bar
  local function fn()
    foo = 1
    bar = 2
  end
end
```
而函数 fn 捕获了主函数的两个局部变量，因此也是闭包。