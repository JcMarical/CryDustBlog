什么？高级语言不就是拿来简化阅读和编写的，怎么还会有人去学汇编...

哎哎，作者人菜瘾大，想看看代码最底层的逻辑。
话不多说，直接开始吧

# 开始
直接学指令真难懂吧！
还是先上一个例子
![](res/Pasted%20image%2020240912212719.png)
# 寄存器
寄存器用来存放临时数据，以8086CPU为例，所有的寄存器都是16位的。
1. %rax 作为函数返回值使用。
2. %rsp 栈指针寄存器，指向栈顶
3. %rbp [栈桢指针](https://zhida.zhihu.com/search?q=%E6%A0%88%E6%A1%A2%E6%8C%87%E9%92%88&zhida_source=entity&is_preview=1)，指向栈基，大部分优化编译-O2其实已经去除了帧指针。
4. %rdi，%rsi，%rdx，%rcx，%r8，%r9 用作函数参数，依次对应第1参数，第2参数。。。
5. %rbx，%r12，%r13，%14，%15 用作数据存储，遵循被调用者使用规则，简单说就是随便用，调用子函数之前要备份它，以防他被修改
6. %r10，%r11 用作数据存储，遵循调用者使用规则，简单说就是使用之前要先保存原值
7. %rip: 相当于PC指针指向当前的指令地址，指向下一条要执行的指令

而带e前缀的寄存器，一般都是只用后8位
![](res/Pasted%20image%2020240912221249.png)
# 地址计算：物理地址，段地址和偏移地址
地址总线一般都设计为20位。
因此用16位段地址+16位偏移地址来计算出物理地址
* 物理地址=段地址X16 + 偏移地址
也就是说段地址在16进制上左移一位再加上偏移地址就是实际的物理地址。
```c++

段:1230
+ 偏移：00c8

物理地址 = 12300 + 00c8 = 123c8

```
其中，我们可以把**段地址X16 + 偏移地址**看作基础地址
# push，pop
push和pop是可以在寄存器和内存传输指令的！！！
* push用来将后面的数据**入栈**，pop用来将后面的数据**出栈**
* 那么铺货


* push 寄存器
* push 段寄存器
* push 内存单元

# mov、add、sub
他们的特点都是由两个操作数，
比如mov，从第二个操作数向第一个操作数传送过去:
* mov 寄存器 ，数据
* mov 寄存器，寄存器
* mov 寄存器，内存单元
* mov 内存单元，寄存器
* mov 段寄存器，寄存器

add，

# call、ret




# 参考
[1. x86-64寄存器和栈帧 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/440016053)