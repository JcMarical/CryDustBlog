- 缺省：即默认
- 浅拷贝：默认拷贝，
    - 问题：内存泄漏，同时修改，多次析构
- 深拷贝：什么位置申请？需要显示提供什么？不共享什么？
    - 什么时候用？传入、返回、初始化。
    - 问题？值传递的多次拷贝与构造问题，解决方法 const Object&，只传递内容
# 1.缺省（default）的概念
你没有预先设置一个值，而是直接让用户去填空，填上一个值。如果这个用户操作出错，导致没有填上这个值，或者用户填的值是错误的（比如让你输入数字你却输入字母），那么我这个程序就要主动地去消除这个错误，也就是填上这个 default value （消除错误的值）。这显然也算是「默认值」，但是这是事后弥补，而非事前预设，所以 **default value 是仅当「缺少」和「省略」的时候才使用的值，故名「 [缺省值](https://www.zhihu.com/search?q=%E7%BC%BA%E7%9C%81%E5%80%BC&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2657914261%7D) 」**。

# 2.浅拷贝
> 不需要自己实现
通过**拷贝构造函数**来实现的，如果程序员**不主动遍历拷贝构造函数和赋值函数**，编译器将会自动生成**缺省的函数**，也就是拷贝时简单地赋值某个对象地指针。
这会造成一些问题：
- b.data 的**内存没释放**，造成**内存泄漏**了。
- b.data 和 a.data 指向了同一块内存，a 或 b **任何一方的值改变都会修改另一方的值**
- **在对象被析构时，data 被释放了两次**

# 3.深拷贝
在**堆区**重新申请内存空间，进行拷贝操作。
深拷贝必须**显式地**提供拷贝**构造函数和赋值运算符**，而且新旧对象**不共享内存**。
什么时候使用深拷贝？
- 一个对象以**值传递**的方式**传入函数体**
- 一个对象以**值传递**的方式**从函数体返回**。
- 一个对象需要**通过另外一个对象进行初始化**。
