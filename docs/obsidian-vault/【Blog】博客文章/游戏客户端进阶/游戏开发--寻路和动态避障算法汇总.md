---
date: 2025-06-28T20:23:10
publish: false
comments: true
permalink: PathFindingAndObstacleAvodiance
aliases:
---

之前总是把寻路和避障算法弄混一团，实际上二者有很大区别，这里将其分类做个总结


# 游戏开发--常见寻路和避障算法总结

# 目录

【寻路篇】
- 预处理寻路算法：定点寻路
- 预处理寻路算法：流场（SDF）寻路
- 广度优先搜索：BFS/双向BFS
- 深度优先搜索：DFS
- 贪心算法：Dijkstra迪杰斯特拉算法
- 启发式搜索：A* 算法
- 启发式搜索：JPS算法
- Navmesh三角漏斗寻路算法

【避障篇】
- RVO算法
- ORCA算法

# 寻路篇

## 1.固定点
预设路径点，不需要路径选择，直接跟着预设点走或者根据特殊条件走不同的预设路线。
优点：速度最快最优
缺点：需要人为摆放，如果场景过大，人工工程量会暴涨。

适用于一些比较固定的移动，如车辆、NPC路线等。
## 2. DFS
用栈存储路径（或者递归），一条路走到底，走不到再回溯。
## 3. BFS
搜外目标点外一圈，再往外搜一圈，一圈一圈向外扩，更适合一些岛屿填充类的算法

## 4.Dijkstra 
> dijkstra算法被证明是单源最短路径问题下的普遍最优算法
## 5.A* 算法
> A* 为什么在游戏中那么常见？因为他的启发式思想能显著提高搜索的速度，在游戏高性能的需求场景里效果显著。其实现比较简单，并且是学习后续一大堆优化算法的核心。不过缺点就是并不能保证最优

**核心思想**：启发式算法，也可以看做是贪心算法的一种，其核心思想是**优先尝试看似更接近目标的路径**。虽然不一定是最终的路径，但是这样可以大幅减少遍历的次数。

而A星算是DFS和BFS的结合，使用了启发函数来对迪杰斯特拉算法进行一些剪枝优化，去除那些在寻路过程中不可能经过的点。

该算法通过**从起点走过的距离+当前节点达到目标点的距离**，计算出**当前距离代价**。并维护一开启列表和关闭列表，分别用来存储下一步可能要走的节点及其距离代价，和已经记录过的路径节点及其父节点。每步从开启列表里寻找代价最小的节点将其加入到关闭列表里形成路径。
## 6. JPS算法
> JPS寻路算法已经被证明是基于无权重格子，在没有预处理情况下最快的寻路算法。

[Unity寻路专题（五）——JPS算法 - 技术专栏 - Unity官方开发者社区](https://developer.unity.cn/projects/628e2f68edbc2a001d6c1c64)

核心思想：“**两个定义，三个规则**”
两个定义：
- 强迫邻居：
- 跳点：
三个规则：
- 规则1：当直线方向(水平方向和垂直方向)均可移动，优先在直线方向搜索跳点
- 规则2：从父节点到当前节点P为直线移动，若有从父节点到P的邻居N且不经过P的路径且该路径小于等于经过P的路径，则下一步不会从P走向N。对角线一样。
- 规则3：只有跳点才会被加入到openList中。(JPS快的原因)
## JPS 和 A* 算法比较
这里有一张比较直观的图能体现出差异，可以看到优化极其显著：
![[Pasted image 20250628205954.png]]
当然还有更详细的流程图示：

![img](https://crydustblog.oss-cn-chengdu.aliyuncs.com/cb50f88b-596a-43d0-a7a6-60cd5a4d162c_JPS_2_.png)