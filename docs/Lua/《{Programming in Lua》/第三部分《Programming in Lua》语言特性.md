# 第三部分《Programming in Lua》语言特性

# 十八 迭代器和泛型 for

## 1.迭代器和闭包
- 迭代器：遍历一个集合中所有元素的代码结构
- 典型：io.read()
- 机制： 保存状态（闭包）
    - 闭包结构 = 闭包本身 + 封装变量的工厂
- 举例，返回元素的值
```lua
function values (t)
    local i = 0
    return function() i = i+1;
    return t[i] end
end
```
在这个例子中，values 就是工厂。每当调用这个工厂时，它就会**创建一个新的闭包**(即迭代器本身)。这个闭包**将它的状态保存在其外部的变量 t 和 i 中**，这两个变量也是由 values 创建的。每次调用这个迭代器时，它就**从列表 t 中返回下一个值**。在遍历完**最后一个元素后迭代器返回 nil**，表示迭代结束。

可以利用 while 或者 for 来使用这个迭代器

## 2. 泛型 for 语法
保存了三个值：
- 一个迭代函数
- 一个不可变状态
- 一个控制变量:变量列表第一个，永远不为 nil
```lua
for var-list in exp_list do
    body
end

for k, v in pairs(t) do print(k, v) end
```

## 3.无状态迭代器（如ipairs）
特点：
1.  不保存任何状态
2.  多个循环使用同一个迭代器，避免创建**新闭包的开销**

ipairs示例：
```lua
lua function iter (t,i)
	i = i+1
	local v = t[i]
	if v then
		return i,v
	end
end

function ipairs( t )
	return iter, t ,0
end

function pairs(t)
	return next,t,nil
end
```


# 二十 元表和元方法
> 可以认为，元表是面向对象领域中的受限制类。像类一样，元表定义的是实例的行为
> 
> 不过，由于元表只能给出**预先定义的操作集合的行为**，所以元表比类更受限。
> 同时，元表也**不支持继承**

* 元表可以修改一个值在面对一个未知操作时的行为。
* Lua 语言中的每一个值都可以有元表
* 每一个**表和用户数据类型**都具有**各自独立的元表**
* 其他类型**共享对应类型所属的同一个元表**
```lua
t = {}
print(getmetatable(t))  -->nil
```
设置元表(在lua种，我们**只能为表设置元表**)
如果要为其他类型的值设置元表，则必须通过**C代码或调试库**完成

```lua
t1 = {}
setmetable(t,t1)
print(getmetatable(t) == t1) -->true
```

一个lua的curWeekCfg表中存储了多行本周精选模块数据，nextWeekCfg表中存储了多行下周预告模块数据。
每个模块具有

1.到达刷新时间时，若当前的下周预告有内容，则之前展示在下周预告的内容则会刷新展示在本周精选模块
2.到达刷新时间时，若已配置下周的下周预告，则会刷新在下周预告的模块中

3.若到达刷新时间点，玩家仍停留在活动界面，则玩家下一次进入界面后再刷新成新的内容

4.到了模块刷新就变，如果当前就是最后的配置了且没有新的模块刷新时间，就一直维持当前的模块

请帮我写出代码