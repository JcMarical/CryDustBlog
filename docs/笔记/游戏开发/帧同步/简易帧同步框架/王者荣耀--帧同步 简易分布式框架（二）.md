# 一  服务器架构
## 多个客户端：
- 客户端A
- 客户端B
- 客户端C
## 网关服务器（既是客户端又是服务端）
发送到
- 网关服务器（用来转发消息）：判断指令是A攻击B（战斗模块）


## 战斗服务器（可能不止战斗）
网关判断指令后再具体发送到
- 战斗服务器进行处理

# 二 网关服务器
## 1.服务器类型enum
## 2.单独新建的gateWay套接字

## 3.单独的ConnetServer、Accept和Receive逻辑


# 三 新定消息协议
# 3.1 客户端给网关
服务器编号：服务器类型的枚举

| 消息长度 | 服务器编号 | 打包的协议 |
| ---- | ----- | ----- |
| 2字节  | 1字节   |       |

### MyGuid静态类
- 哈希Set存已有id
- 获取逻辑
	- 静态变量id，获取时自增
	- 超过uintMax，重新设为0
	- 循环遍历Set，重复则继续递增
	- 加入到Set中
	- 返回id

### 客户端GUID对象字典
id，对应客户端对象

## 3.2 网关给客户端
传消息就行了

| 消息长度 | 服务器编号 | 打包的协议 |
| ---- | ----- | ----- |
| 2字节  | 1字节   |       |
## 3.3 服务端给网关
不需要服务器编号了

| 消息长度  | guid  | 打包的协议 |
| ----- | ----- | ----- |
| 2byte | 4byte |       |

## 3.3 网关给其他服务器的通信协议
已经在发送前指定服务端发送了，就不需要再加入发送

| 消息长度  | guid  | 打包的协议 |
| ----- | ----- | ----- |
| 2byte | 4byte |       |


## 3.4 客户端给网关的通信协议规定
这里要去客户端重新写一下

| 消息长度  | 服务端编号 | 打包的协议 |
| ----- | ----- | ----- |
| 2byte | 1byte |       |

## 四 战斗服
- 不需要心跳机制
- 不需要网络事件

- 战斗服接收到消息就直接处理，也不需要再update逐帧定量处理消息了

## 4.1 处理Send
需要根据guid进行处理：

## 4.2 Main连接
- 

# 五 MainClass
- 分配一个IP+端口 提供给**战斗服务器**连接
- 分配一个IP+端口 提供给socket连接

# 六 UDP通讯
## 6.1 在GateWay创建UDPClient(Socket)
- 一个负责客户端UDP通讯
- 一个负责服务端UDP通讯
在Accept逻辑里，绑定IP的端口（可以和TCP的一致），创建监听对象。

## 6.2 UDP的Receive
### 客户端转发到服务端
- 要创建一个IPEndPoint，用来记录发消息的客户端的IP和端口。
- 使用一个byte数组存**UDP数据报**。不需要拆包了
- 取第一字节的服务器地址，再存入GUID
- 转发到服务端类型对应的服务端Socket去
- 递归处理，继续receive客户端消息。
### 服务端转发到客户端
思路一样的，消息解析不同罢了

